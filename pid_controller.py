import streamlit as st
import numpy as np
from bokeh.plotting import figure
from bokeh.layouts import column, row
from bokeh.models import ColumnDataSource, Slider, CustomJS

# Predefined system configurations
SYSTEM_CONFIGS = {
    "Pure Oscillator (Undamped)": {
        "description": "System with no natural damping (like an ideal pendulum in vacuum)",
        "damping_ratio": 0.0,
        "natural_freq": 2.0,
        "recommended_gains": {"Kp": 1.0, "Ki": 0.0, "Kd": 0.3}
    },
    "Underdamped Mechanical System": {
        "description": "A typical mass-spring-damper system (like a car suspension)",
        "damping_ratio": 0.2,
        "natural_freq": 2.0,
        "recommended_gains": {"Kp": 2.0, "Ki": 0.1, "Kd": 0.5}
    },
    "Chemical Reactor": {
        "description": "Slower system with thermal lag (like temperature control)",
        "damping_ratio": 0.7,
        "natural_freq": 0.5,
        "recommended_gains": {"Kp": 1.0, "Ki": 0.05, "Kd": 0.2}
    },
    "Fast Servo Motor": {
        "description": "Quick responding positioning system",
        "damping_ratio": 0.1,
        "natural_freq": 5.0,
        "recommended_gains": {"Kp": 3.0, "Ki": 0.2, "Kd": 0.8}
    },
    "Critically Damped Load": {
        "description": "Balanced response (like a well-tuned door closer)",
        "damping_ratio": 1.0,
        "natural_freq": 1.0,
        "recommended_gains": {"Kp": 1.5, "Ki": 0.1, "Kd": 0.4}
    },
    "Custom System": {
        "description": "Fully adjustable parameters",
        "damping_ratio": 0.5,
        "natural_freq": 2.0,
        "recommended_gains": {"Kp": 2.0, "Ki": 0.1, "Kd": 0.5}
    }
}

def pid_simulation(Kp, Ki, Kd, setpoint, damping_ratio, natural_freq, simulation_time=10, dt=0.01):
    """
    Simulate PID controller response for a second-order system with adjustable damping
    """
    # Time points
    t = np.arange(0, simulation_time, dt)
    
    # Initialize arrays
    process_variable = np.zeros_like(t)
    velocity = np.zeros_like(t)
    error = np.zeros_like(t)
    integral = np.zeros_like(t)
    derivative = np.zeros_like(t)
    control_signal = np.zeros_like(t)
    
    # Initial conditions
    process_variable[0] = 0
    velocity[0] = 0
    
    # System parameters
    mass = 1.0
    k = mass * natural_freq**2
    c = 2 * damping_ratio * np.sqrt(mass * k)
    
    for i in range(1, len(t)):
        # Calculate error
        error[i] = setpoint - process_variable[i-1]
        
        # Calculate integral term
        integral[i] = integral[i-1] + error[i] * dt
        
        # Calculate derivative term
        derivative[i] = (error[i] - error[i-1]) / dt
        
        # PID control signal
        control_signal[i] = Kp * error[i] + Ki * integral[i] + Kd * derivative[i]
        
        # Simulate second-order system response
        spring_force = k * process_variable[i-1]
        damping_force = c * velocity[i-1]
        
        # Calculate acceleration
        acceleration = (control_signal[i] - spring_force - damping_force) / mass
        
        # Update velocity and position
        velocity[i] = velocity[i-1] + acceleration * dt
        process_variable[i] = process_variable[i-1] + velocity[i] * dt
    
    return t, process_variable, control_signal, error

# Streamlit app
st.title('PID Controller Simulation')

# System selection
st.sidebar.header('System Selection')
selected_system = st.sidebar.selectbox(
    'Choose a System',
    list(SYSTEM_CONFIGS.keys())
)

# Display system description
st.markdown(f"**Selected System:** {selected_system}")
st.markdown(f"*{SYSTEM_CONFIGS[selected_system]['description']}*")

st.markdown("""
### Understanding System Inputs and Responses

In these second-order systems:

1. **Input Force (Control Signal)**:
   - Generated by the PID controller
   - Tries to move the system toward the setpoint
   - Like pushing/pulling a mass or heating/cooling a reactor

2. **System Response**:
   - Depends on three main factors:
     - Mass/Inertia (m): Resistance to change in motion
     - Spring Stiffness (k): Restoring force
     - Damping (c): Natural resistance/friction

3. **Natural Frequency** (ωn = √(k/m)):
   - Higher value = faster oscillations
   - Lower value = slower oscillations
   - Like a stiff vs loose spring

4. **Damping Ratio** (ζ = c/(2√(mk))):
   - ζ = 0: Pure oscillation (no energy loss)
   - 0 < ζ < 1: Oscillatory with decay
   - ζ = 1: Critical damping (fastest non-oscillatory)
   - ζ > 1: Overdamped (slow return)
""")

# System parameters
st.sidebar.header('System Parameters')
if selected_system == "Custom System":
    damping_ratio = st.sidebar.slider('Damping Ratio (ζ)', 0.0, 2.0, 
                                    SYSTEM_CONFIGS[selected_system]['damping_ratio'], 0.1)
    natural_freq = st.sidebar.slider('Natural Frequency (ωn)', 0.1, 5.0, 
                                   SYSTEM_CONFIGS[selected_system]['natural_freq'], 0.1)
else:
    damping_ratio = SYSTEM_CONFIGS[selected_system]['damping_ratio']
    natural_freq = SYSTEM_CONFIGS[selected_system]['natural_freq']
    st.sidebar.markdown(f"Damping Ratio (ζ): {damping_ratio}")
    st.sidebar.markdown(f"Natural Frequency (ωn): {natural_freq}")

# Controller parameters
st.sidebar.header('Controller Parameters')
recommended_gains = SYSTEM_CONFIGS[selected_system]['recommended_gains']
Kp = st.sidebar.slider('Proportional Gain (Kp)', 0.0, 5.0, recommended_gains['Kp'], 0.1)
Ki = st.sidebar.slider('Integral Gain (Ki)', 0.0, 2.0, recommended_gains['Ki'], 0.1)
Kd = st.sidebar.slider('Derivative Gain (Kd)', 0.0, 2.0, recommended_gains['Kd'], 0.1)
setpoint = st.sidebar.slider('Setpoint', 0.0, 10.0, 5.0, 0.1)

# Run simulation
t, pv, cv, error = pid_simulation(Kp, Ki, Kd, setpoint, damping_ratio, natural_freq)

# Create Bokeh figure for Process Variable
p1 = figure(title='Process Variable vs Setpoint', x_axis_label='Time (s)', y_axis_label='Value',
           width=800, height=400)
p1.line(t, pv, line_color='blue', legend_label='Process Variable')
p1.line(t, [setpoint]*len(t), line_color='red', line_dash='dashed', legend_label='Setpoint')
p1.legend.location = 'right'

# Create Bokeh figure for Control Signal
p2 = figure(title='Control Signal', x_axis_label='Time (s)', y_axis_label='Value',
           width=800, height=400)
p2.line(t, cv, line_color='green', legend_label='Control Signal')
p2.legend.location = 'right'

# Create Bokeh figure for Error
p3 = figure(title='Error', x_axis_label='Time (s)', y_axis_label='Value',
           width=800, height=400)
p3.line(t, error, line_color='red', legend_label='Error')
p3.legend.location = 'right'

# Display plots using Streamlit
st.bokeh_chart(p1)
st.bokeh_chart(p2)
st.bokeh_chart(p3)

# Calculate and display performance metrics
steady_state_error = abs(error[-1])
max_overshoot = max(0, (max(pv) - setpoint) / setpoint * 100) if setpoint != 0 else 0
settling_threshold = 0.02 * setpoint
settling_indices = np.where(abs(pv - setpoint) <= settling_threshold)[0]
settling_time = t[settling_indices[0]] if len(settling_indices) > 0 else "N/A"

# System metrics display
st.sidebar.header('System Metrics')
metrics_col1, metrics_col2 = st.sidebar.columns(2)

with metrics_col1:
    st.markdown("**Performance Metrics:**")
    st.markdown(f"Final Error: {steady_state_error:.3f}")
    st.markdown(f"Maximum Overshoot: {max_overshoot:.1f}%")
    st.markdown(f"Settling Time (±2%): {settling_time if isinstance(settling_time, str) else f'{settling_time:.2f}s'}")

with metrics_col2:
    st.markdown("**System Characteristics:**")
    if damping_ratio < 1:
        st.markdown(f"Type: Underdamped")
        wd = natural_freq * np.sqrt(1 - damping_ratio**2)
        st.markdown(f"Damped Frequency: {wd:.2f} rad/s")
    elif damping_ratio == 1:
        st.markdown(f"Type: Critically Damped")
    else:
        st.markdown(f"Type: Overdamped")